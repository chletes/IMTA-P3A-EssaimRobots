%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                    VIRTUAL AXLE-TREE SIMULATOR
%
% Simulation of two mobile robots (tank-like) that must drive in a parallel way, with a
% constant inter-distance (so-calle side-tracking problem), their common
% barycenter having to follow a given reference trajectory.
%
% Author : F. Claveau
% Version : 2016/09/27
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     Principle of the control strategy
%
% A two layer control strategy is implemented. Each robots is driven thanks
% to a linearizing feedback (classic approach), leading to a closed-loop
% behavior of each robot in the plan described as (decoupled double integrator):
%
%  /
% | x_dot_dot = wx
% | y_dot_dot = wy
%  \
%
% Concretely, the two robots are both described by two second order model.
% In respect with the linearizing feedback theory, after having obtained
% the two decoupled double integrator, two PD regulators are implemented
% leading to a behavior of a second order system.
%
% In the top layer, to drive the two robots according to the given
% objective, a MIMO LQ (H2) control strategy is developed. The controlled
% outputs are in the number of 4, 2 associated to the reference tracking of
% the barycenter (outputs h1 and h2), and 2 are associated to the
% regulation of the distance between the two robots (outputs h3 and h4):
%
% h1 = xG = (x1+x2)/2 = (x_d+x_g)/2
% h2 = yG = (y1+y2)/2 = (y_d+y_g)/2
% h3 = d_proj_X = x_d - x_g
% h4 = d_proj_Y = y_g - y_d
%
% h3 and h4 can be seen as the projection on x and y axis of the euclidian distance 
% between the two robots.
%
% Notice that the orientation of the robot is not considered here, i.e.
% they are supposed as symmetric, i.e. we don't distinguish the front and
% the rear of the robot, i.e. it can move forward and backward.
%
% Design of the LQ controller is based on the 2 robots x 2 direction (X,Y)
% x 2nd order = 8 states model of the closed-loop robots. As we have to
% ensure the trajectory tracking, a feedforward static gain as also to be
% design. We used the "Occultation principle" (based on Sylvester equation
% - see teaching of Ph. Chevrel or Ph. De Larminat) to design it.
%
% The trajectory for the baricenter of the two robots as been generated
% following the theory of the "virtual robot tracking". The trajectory as
% been generated by using an ideal "virtual robot" model that we have to
% follow; it is a trajectory, i.e. based on a path but also on a timing we
% have to respect.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


clear all
addpath('Sub_functions/');

% Configuration of the plot animation of the two mobile robots
figure(1)
clf;
set(gcf, 'renderer', 'zbuffer');
axis([-6,15, -6,15]);

%% ******************************************************************************************%
%  Problem formulation and design of the MIMO H2/LQ (upper layer) for the Virtual AxleTree
%********************************************************************************************%
% Definition of the complete model of the virtual axletree, i.e. involving
% the two decoupled integrator chain of the two direction (x,y) of the two
% robots.
    % Assuming a linearizing feedback applied on each of the two robots, each
    % robot can be described by:
    %  /
    % | x_dot_dot = wx
    % | y_dot_dot = wy
    %  \
    % Each decoupled direction x or y is considered closed-loop thanks to a
    % PD control tuned as u=(2+2s)e. That leads to the following
    % closed-loop expression x/xref or y/yref = (2+2s)/(s^2+2*s+2).
    % The state-space representation is needed. In the chosen one, if the
    % first state X1 as some physical meaning (position x or y of the
    % robot), it is not the case of the second state X2 (i.e. it is not the
    % velocity x_dot or y_dot).
    % Useful in the following; x2 can be estimated thanks to the measurable 
    % position x or y according to the formula: X2 = -3.X1 -2.X1_pt + 4xref.
    Adr = [-1.5 -0.5 ; 2.5 -0.5];
    Bdr = [2 ; -2];
    Cdr = [1 0 ; 1 0 ; 0 1];
    Ddr = [0 ; 0 ; 0];
    Chain = ss(Adr,Bdr,Cdr,Ddr);
    
    % Definition of the standard model involving the 2x2 = 4 states model
    % of the two robots.
        % Definition of the LQ ponderation (involved directly in the
        % controlled output in the spirit of H2 control formulation)
        r = 1;
        q = 1;
        q1 = q; q2 = q; q3 = q; q4 = q;
        
        % Definition of the standard model (without the model of the
        % exogenous system describing the reference trajectory)
        % Notation: index "d" is for "droite", i.e. "right" in french, "g"
        % for "gauche", i.e. "left".
        [Aglob,Bglob,Cglob,Dglob] = linmod('Linm_MSP');
        Tb = [eye(2) zeros(2,6) ; zeros(2,4) eye(2) zeros(2);zeros(2) eye(2) zeros(2,4);zeros(2,6) eye(2)];
        MSP = ss(Tb*Aglob*inv(Tb),Tb*Bglob,Cglob*inv(Tb),Dglob);
        MSP.StateName  = {'xd','xd_2','yd','yd_2','xg','xg_2','yg','yg_2'};
        MSP.InputName  = {'wx_d','wy_d','wx_g','wy_g'};
        MSP.OutputName = {'h1','h2','h3','h4',...
                          'xd','xd_2','yd','yd_2','xg','xg_2','yg','yg_2'};
    
        % Definition of a state-space model of the reference signal for each outputs
        % h1, h2, h3, h4 - Useful to design the feedforward static gain
        % dedicated to the tracking problem.
        % A "ramp" model (double integrator) is assumed for h1 and h2, and
        % a constant "step" model (simple integrator) is assumed for h3 and h4.
        Adi = [0 1 ; 0 0];
        Bdi = [0 1];
        Cdi = [1 0];
        C2glob = blkdiag(q1*Cdi,q2*Cdi,q3*[1],q4*[1]);
        A22 = blkdiag(Adi,Adi,[0],[0]);
        A12 = zeros(8,6);
        A21 = zeros(6,8);
        Amsp = [MSP.A A12 ; A21 A22];
        B2msp = [MSP.B ; zeros(6,4)];
        C1glob = MSP.C(1:4,:);
        C1msp = [-C1glob C2glob];

% Design of the feedback Kglob and feedforward gain Kff        
    % LQ problem, solved in the continuous framework
    % wfb = - Kglob.X
    Q = C1glob'*C1glob;
    R = r*eye(4);
    [P,L,Kglob] = care(MSP.A,MSP.B,Q,R);                % Kglob is implemented finally...
    %Klq = ss(Kglob);                                    % S.S. not used...
    % Klq.InputName = {'xd','xd_2','yd','yd_2','xg','xg_2','yg','yg_2'};
    % Klq.OutputName = {'wx_d','wy_d','wx_g','wy_g'};
    
    % Design of the feedforward static gain Kff for the reference trajectory 
    % wff = Kff*yref
    fprintf('Design of Kff : instable exogenous model, 4 controlled output, use of EQREJ function\n')
    [Taeq, Gaeq]=Eqrej(Amsp,B2msp,C1msp,8);
    Kff = Kglob*Taeq + Gaeq;
    
    fprintf('=========================================================\n')


%********************************************************************************************%
%********************************************************************************************%


%% ******************************************************************************************%
%       Initialisation of the system and of the trajectory reference for simulation 
%********************************************************************************************%
% Initialisation of the two robots 
    % Initialisation of the barycenter
    %x = [3;1;50*pi/180;0.1];                                % Initial state of the barycenter
    x = [2;2;45*pi/180;0.1];                                 % X = [x,y,theta,v]
    xd = [0;0;0;0];                                          % Initial derivative of the barycenter state                        
    d  = 2;                                                  % Inter-distance norm between the two robots
    
    % Initialisation of the control signal for the two robots
    % Notice that the 4 control signals provided by the upper layer
    % MIMO controller are homogeneous to a position, i.e. the upper layer
    % provide to the embedded
    wff = [0;0;0;0];                                        % Definition of the feedforward MIMO control signal
                                                            % wff = [wx_d_ref;wy_d_ref;wx_g_ref;wy_g_ref] = Kff [h1ref;h1ref_dot;h2ref;h2ref_dot;h3ref;h4ref]
    wfb = [0;0;0;0];                                        % Definition of the MIMO LQ feedback control 
                                                            % wfb = [wx_d;wy_d;wx_g;wy_g] = Klq [X]
    w   = wff + wfb;                                        % Definition of the complete control signal
    dw  = [0;0;0;0];                                        % Definition of the complete derivative of the control signal
      
    % Initialisation of the state and the physical control signal of the two robots 
    x_d = [x(1)+d/2*sin(x(3));x(2)-d/2*cos(x(3));...        % Definition of the initial state x = [x,y,theta,v]  
           90*pi/180 ; 0.1];                                % x,y : longitudinal and lateral position of the robot                                                      
    x_g = [x(1)-d/2*sin(x(3));x(2)+d/2*cos(x(3));...        % theta,v : orientation and velocity
           45*pi/180 ; 0.1];                                % x_g,  x_d: "g" is for "gauche = left", "d" for "droite = right"
    xd_d = [0;0;0;0.1];                                     % Initial derivative of the robots state, v_dot must not be zero (numerical problem)
    xd_g = [0:0;0;0.1];                                     % !!! Notice that xd_ is different from x2_ !!!
    x2_d = [0 ; 0 ; 0 ; 0];                                 % Definition of the second state of one "double integrator" chain
    x2_g = [0 ; 0 ; 0 ; 0];                                 % according to the standard model used to design the MIMO LQ controller
    
    dxy = [x_d(1) - x_g(1) ; x_g(2) - x_d(2)];              % Interdistance between the two robots on (0x) and (0y)
    ddxy = [0 ; 0];                                         % Derivative of the interdistance 
    
    u_d = [0;0.01];                                         % Definition of the physical control signal for each robot, u = [theta_dot,v_dot=acceleration]
    u_g = [0;0.01];                                         
   
    Xglob = [x_d(1) ; xd_d(1) ; x_d(2) ; xd_d(2);...        % Initial complete state vector used by the LQ feedback gain
             x_g(1) ; xd_g(1) ; x_g(2) ; xd_g(2)];
     
% Initialisation of the trajectory reference for the barycenter and the interdistance (based thanks to a virtual mobile robot)
xref = [2;2;20*pi/180];                         % Initial state of the Barycenter G [xG_ref,yG_ref,thetaG_ref]
xdref = [0;0;0];                                % Initial derivative state                        
uref = [0 ; 0];                                 % Initial control signal for the virtual robot [theta_dot,v_dot]
dxyref = [d*sin(xref(3));...                    % Definition of the initial interdistance
          d*cos(xref(3))];                      % projected on the axis (Ox) and (Oy)
ddxyref=[0 ; 0];                                % Derivative of the reference of interdistance     


xref_trace = xref;                              % For some technical reason, the reference trajectory used in the simulation
xdref_trace = [0;0;0];                          % and the one used for the plotting are distinguised. Here initialization
uref_trace = [0 ; 0];                           % of the plotted trajectory is done.

xocc_ref = [xref(1);xdref(1);xref(2);...        % Initial complete state vector used by the LQ feedback gain
            xdref(2);dxyref(1);dxyref(2)];


% Time Sampling and Duration of the simulation
t = 0;                          % Simulation initialisation
dt = 0.02;                      % Sampling Period
t_final = 10;                   % Simulation end
t_save = [0 t:dt:t_final];

% Back-up of the states, control signals, of the robots or the references signals
xref_save = xref;
xdref_save = xdref;
x_save = x;
xd_save = xd;
wfb_save = wfb;
wff_save = wff;
w_save = w;
dw_save = dw;
x_dsave = x_d;
x_gsave = x_g;
u_dsave = u_d;
u_gsave = u_g;
dxy_save = dxy;
ddxy_save = ddxy;
dxyref_save = dxyref;
ddxyref_save = ddxyref;
Xglob_save = Xglob;

%********************************************************************************************%
%********************************************************************************************%


%% ******************************************************************************************%
%                 Trajectory generation for plotting
%********************************************************************************************%
% !!! An other trajectory is generated in "real-time" in the "for" loop
% used for the concrete simulation - both trajectory references must be
% tuned, initialized, in the same way !!!
for t=0:dt:t_final
    % Barycenter G trajectory: [xG_ref,yG_ref,thetaG_ref] is needed at each step time
        % A virtual robot (tank-like) is used to generated a trajectory
        % consistent with the non-holonomy properties of the two "real" robots.
        % uref_trace(1,:) = v, velocity of the virtual robot, 
        % uref_trace(2,:) = theta_dot, orientation angular speed of the virtual robot.
        uref_trace(1,:) = 1;    uref_trace(2,:) = 5*pi/180;     % Simple curve trajectory
                                               %cos(t)-1/4;     % Complex multi-curve trajectory
        xdref_trace = evol_trajectoire(xref_trace,uref_trace);  % Kinematic model of the tank-like virtual robot
        xref_trace = xref_trace + xdref_trace*dt;               % Integration of the state of the reference virtual robot
        xref_save = [xref_save xref_trace];
        xdref_save = [xdref_save xdref_trace];
           
end

%********************************************************************************************%
%********************************************************************************************%


%% ******************************************************************************************%
% Temporal simulation of the two robots, with implementation of the upper layer MIMO LQ
% controller (with feedforward), and linearizing feedback for each single robots.
%********************************************************************************************%
% Loop of simulation
for t=0:dt:t_final
t = t + dt; 
    
    % Computation of the upper layer control signals [wx_d;wy_d;wx_g;wy_g]
    % in fact position (x,y) references for inner-loops of each robots
        % Computation of the feedforward control signal wff (trajectory tracking)
        %wff = [0;0;0;0];                           % Useful for debugging
        %wff = [t;t;t;t];
        wff = -Kff*xocc_ref;
        wff_save = [wff_save wff];
        
        % Computation of the LQ feedback control signal wfb
        %wfb = [0;0;0;0];                           % Useful for debugging
        wfb = -Kglob*Xglob;
        wfb_save = [wfb_save wfb];
        
        % Calcul du signal de commande complet
        % w = [wx_d;wy_d;wx_g;wy_g]                 % Reminder: d -> "droite = right", g -> "gauche = left"
        w = wff + wfb;
        dw = w_save(:,end) - w;                     % Derivative of w, i.e. variation of w between step time k and (k-1)
        w_save = [w_save w];
        dw_save = [dw_save dw];
    
    %----------------------------------------------------------------------
    %
    % w and dw are the 4+4 = 8 signals that must be transmitted by the
    % upper layer (i.e. the supervisor computer) in wifi, bluetooth
    % protocol to the two robots with the embedded linearizing control
    % loops.
    %
    % In simulation, that's mean that w and dw signals must be disturbed
    % thanks to the model of packet losses and so on...
    %
    %----------------------------------------------------------------------
    
    % Computation of the two inner loops embedded in the two robots
    % Computation of right (droite) and left (gauche) local control signals 
        % w_d = [wx_d,wy_d] et w_g = [wx_g,wy_g]
        % Extraction of w_d, w_g and of the derivative signals dw_d et dw_g
        w_d  = w(1:2);
        w_g  = w(3:4);
        dw_d = dw(1:2);
        dw_g = dw(3:4);
            
        % Right Robot: computation of the linearizing feedback
        v_d = 2*(w_d-x_d(1:2)) + 2*(dw_d(1:2)-xd_d(1:2));                           % PD controller
        A_d = [-x_d(4)*sin(x_d(3)) cos(x_d(3)) ; x_d(4)*cos(x_d(3)) sin(x_d(3))];   % Linearizing feedback
        u_d = inv(A_d)*v_d;                                                         % u_d = [theta_dot_d ; acc_d]
        u_dsave = [u_dsave u_d];
            
        % Left Robot: computation of the linearizing feedback
        v_g = 2*(w_g-x_g(1:2)) + 2*(dw_g(1:2)-xd_g(1:2));                           % PD controller
        A_g = [-x_g(4)*sin(x_g(3)) cos(x_g(3)) ; x_g(4)*cos(x_g(3)) sin(x_g(3))];   % Linearizing feedback
        u_g = inv(A_g)*v_g;                                                         % u_g = [theta_dot_g ; acc_g]      
        u_gsave = [u_gsave u_g];
               
    % Computation of the kinematic evolution of the two robots
            % Motion of the right robot
            xd_d = evol_robot_type20(x_d,u_d);
            x_d = x_d + xd_d*dt;
            x_dsave = [x_dsave x_d];
            
            % Estimation of the second state x2 (in the basis of the LQ
            % standard model) of the robot in closed-loop (PD+linearization)
            % Cf. comments in the LQ design section
            x2_d = -3*x_d(1:2,:) -2*xd_d(1:2,:) + 4*w_d;
            
            % Motion of the left robot
            xd_g = evol_robot_type20(x_g,u_g);
            x_g = x_g + xd_g*dt;
            x_gsave = [x_gsave x_g];
           
            % Estimation of the second state x2 (in the basis of the LQ
            % standard model) of the robot in closed-loop (PD+linearization)
            % Cf. comments in the LQ design section
            x2_g = -3*x_g(1:2,:) -2*xd_g(1:2,:) + 4*w_g;
            
            % Computation of the evolution of the interdistance between the
            % two robots
            dxy_old(1) = dxy(1);
            dxy_old(2) = dxy(2);
            dxy = [x_d(1) - x_g(1) ; x_g(2) - x_d(2)];
            dxy_save = [dxy_save dxy];
            ddxy(1) = dxy(1)-dxy_old(1);
            ddxy(2) = dxy(2)-dxy_old(2);
            ddxy_save = [ddxy_save ddxy];
            
            % Definition of the state vector used for the LQ implementation
            Xglob = [x_d(1) ; x2_d(1) ; x_d(2) ; x2_d(2);...
                     x_g(1) ; x2_g(1) ; x_g(2) ; x2_g(2)];
            Xglob_save = [Xglob_save Xglob];
            
            % Computation of the evolution of the barycenter G
            x_old(1) = x(1);
            x_old(2) = x(2);
            x(1) = (x_d(1)+x_g(1))/2;
            x(2) = (x_d(2)+x_g(2))/2;
            x(3) = (x_d(3)+x_g(3))/2;                           % ??? Good ??? Not used...
            xd(1)=x(1)-x_old(1);                                
            xd(2)=x(2)-x_old(2);
            x_save = [x_save x];
            xd_save = [xd_save xd];
            
    % Generation of the reference trajectory - in the same spirit that for
    % the plotting of this reference trajectory...
    % A each step time we need: [xG_ref,yG_ref,dref_x,dref_y]
        % Computation of the reference trajectory for G
        % i.e. reference signals for controlled output h1 and h2
        % based on the kinematic model of tank-like "virtual" robot
        uref(1,:) = 1;    uref(2,:) = 5*pi/180;     % Simple curve trajectory
                                   %cos(t)-1/4;     % Complex multi-curves trajectory
        xdref = evol_trajectoire(xref,uref);            
        xref = xref + xdref*dt;
        
        % Computation of the reference signals for the interdistance between the two robots
        % i.e. reference signals for controlled output h3 and h4
        dxyref_old(1) = dxyref(1);
        dxyref_old(2) = dxyref(2);
        dxyref = [d*sin(xref(3)) ; d*cos(xref(3))];
        dxyref_save = [dxyref_save dxyref];
        ddxyref(1) = dxyref(1)-dxyref_old(1);
        ddxyref(2) = dxyref(2)-dxyref_old(2);
        ddxyref_save = [ddxyref_save ddxyref];
        
        % Definition of the reference state vector used for the feedforward implementation 
        xocc_ref = [xref(1);xdref(1);xref(2);xdref(2);dxyref(1);dxyref(2)];
        
       
    % Animation of robots right and left following the desired trajectory
    draw_2_robot(x_d,x_g,xref_save);
        
end

%********************************************************************************************%
%********************************************************************************************%


%% ******************************************************************************************%
%                              Plots of the different signals
%********************************************************************************************%
% Trajectories of the barycenter G, its reference, and the two robots
figure (2)
subplot(2,1,1)
plot(xref_save(1,:),xref_save(2,:),'k*',x_save(1,:),x_save(2,:),'r',...
     x_dsave(1,:),x_dsave(2,:),'g--',x_gsave(1,:),x_gsave(2,:),'b--');
title('Trajectories of the barycenter G, its reference, and the two robots');
legend('traj ref G','traj barycenter G','traj robot D Right','traj robot G Left',0)
xlabel('x (m)');ylabel('y (m)');
subplot(2,1,2)
plot(t_save,180/pi*x_dsave(3,:),'r',t_save,180/pi*x_gsave(3,:),'g--');
title('Robots orientation');
legend('\Theta_d °','\Theta_g °',0);
xlabel('t');ylabel('degree');

% Summary of barycenter trajectory in the plane, orientation of the robots,
% of the angular velocity and linear velocity of the two robots
figure (3)
subplot(2,2,1)
plot(xref_save(1,:),xref_save(2,:),'k',x_save(1,:),x_save(2,:),'r--');
title('trajectory of the barycenter in the plane');
legend('traj reference for G','traj barycenter G',0);
xlabel('x (m)');ylabel('y (m)');

subplot(2,2,2)
plot(t_save,180/pi*(xref_save(3,:)),'k',t_save,180/pi*x_save(3,:),'r--');
title('orientation of the virtual robot used to generate the reference trajectory');
legend('\Theta_{ref}','\Theta °',0);
xlabel('t');ylabel('degree');

subplot(2,2,3)
plot(t_save,180/pi.*u_dsave(1,:),'k',t_save,180/pi.*u_gsave(1,:),'r--');
title('Plot of physical control signals applied on the robots u_d and u_g - angular speed');
legend('w_d °/s','w_g °/s',0);
xlabel('t');ylabel('degree/s');

subplot(2,2,4)
plot(t_save, u_dsave(2,:),'k',t_save,u_gsave(2,:),'r--');
title('Plot of physical control signals applied on the robots u_d and u_g -  acceleration');
legend('acc_d','acc_g',0);
xlabel('t');ylabel('m/s²');

% Plotting of the inter-distance performance
figure (4)
subplot(1,3,1)
plot(t_save,dxyref_save(1,:),'k',t_save,dxy_save(1,:),'r--');
title('Error on the x axis');
legend('Ref d on x axis','d on x axis',0);
xlabel('t');ylabel('m');

subplot(1,3,2)
plot(t_save,dxyref_save(2,:),'k',t_save,dxy_save(2,:),'r--');
title('Error in the y axus');
legend('Ref d on y axis','d on y axis',0);
xlabel('t');ylabel('m');

subplot(1,3,3)
plot(t_save,sqrt(dxyref_save(1,:).^2+dxyref_save(2,:).^2),'k',t_save,sqrt(dxy_save(1,:).^2+dxy_save(2,:).^2),'r--');
title('Euclidian Norm of the interdistance d');
legend('Reference interdistance d_ref','interdistance d',0);
xlabel('t');ylabel('m');

% Plotting of the LQ feedback signals
figure(5)
plot(t_save,wfb_save(1,:),'k',t_save,wfb_save(2,:),'r--',t_save,wfb_save(3,:),'g',t_save,wfb_save(4,:),'b--');
title('LQ feedback signals');
legend('wx_d','wy_d','wx_g','wy_g',0);
xlabel('t');ylabel('m');   

% Plotting of the feedforward signals
figure(6)
plot(t_save,wff_save(1,:),'k',t_save,wff_save(2,:),'r--',t_save,wff_save(3,:),'g',t_save,wff_save(4,:),'b--');
title('Feedforward signals');
legend('wx^{ref}_d','wy^{ref}_d','wx^{ref}_g','wy^{ref}_g',0);
xlabel('t');ylabel('m');  

% Plot of physical control signals applied on the robots u_d and u_g (output of the linearizing feedback)
figure(7)
plot(t_save,u_dsave(1,:),'k',t_save,u_dsave(2,:),'r--',t_save,u_gsave(1,:),'g',t_save,u_gsave(2,:),'b--');
title('Physical control signals');
legend('w_d','a_d','w_g','a_g',0);
xlabel('t');ylabel('m/s² ou rad/s²');  

% Plot according to the time of the x and y position of the barycenter G
figure(8)
subplot(2,1,1)
plot(t_save,xref_save(1,:),'k',t_save,x_save(1,:),'r--');
title('x position of the barycenter G');
legend('xG_{ref}','xG',0);
xlabel('t');ylabel('m');
subplot(2,1,2)
plot(t_save,xref_save(2,:),'k',t_save,x_save(2,:),'r--');
title('y position of the barycenter G');
legend('yG_{ref}','yG',0);
xlabel('t');ylabel('m');

% Error signal for the 4 controlled ouputs
figure(9)
subplot(2,2,1)
plot(t_save,xref_save(1,:)-x_save(1,:),'r')
legend('e_{x_G}',0);
xlabel('t');ylabel('m');
subplot(2,2,2)
plot(t_save,xref_save(2,:)-x_save(2,:),'r')
legend('e_{y_G}',0);
xlabel('t');ylabel('m');
subplot(2,2,3)
plot(t_save,dxyref_save(1,:)-dxy_save(1,:),'r')
legend('e_{\Deltax_G}',0);
xlabel('t');ylabel('m');
subplot(2,2,4)
plot(t_save,dxyref_save(2,:)-dxy_save(2,:),'r')
legend('e_{\Deltay_G}',0);
xlabel('t');ylabel('m');

% Performance of the PD+linearizing feedback for the two robots
    % Right Robot
    figure (10)
    subplot(2,1,1)
    plot(t_save,w_save(1,:),'k',t_save,x_dsave(1,:),'r--');
    title('ref position x and position x');
    legend('wx_d as ref','x_d',0);
    xlabel('t');ylabel('m');
    subplot(2,1,2)
    plot(t_save,w_save(2,:),'k',t_save,x_dsave(2,:),'r--');
    title('ref position y and position y');
    legend('wy_d as ref','y_d',0);
    xlabel('t');ylabel('m');

    % Left Robot
    figure (11)
    subplot(2,1,1)
    plot(t_save,w_save(3,:),'k',t_save,x_gsave(1,:),'r--');
    title('ref position x and position x');
    legend('wx_g as ref','x_g',0);
    xlabel('t');ylabel('m');
    subplot(2,1,2)
    plot(t_save,w_save(4,:),'k',t_save,x_gsave(2,:),'r--');
    title('ref position y and position y');
    legend('wy_g as ref','y_g',0);
    xlabel('t');ylabel('m');
